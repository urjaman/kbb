From 89b34cdcc75fa26963bbb210e0521b7394d0fefb Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Mon, 27 Aug 2018 10:30:55 +0000
Subject: [PATCH 01/15] drivers: clk-rk3288: support for dedicating NPLL to a
 VOP

As controlled by the just introduced dts property.

Signed-off-by: Urja Rannikko <urjaman@gmail.com>
---
 drivers/clk/rockchip/clk-rk3288.c | 69 +++++++++++++++++++++++++------
 drivers/clk/rockchip/clk.h        |  3 ++
 2 files changed, 60 insertions(+), 12 deletions(-)

diff --git a/drivers/clk/rockchip/clk-rk3288.c b/drivers/clk/rockchip/clk-rk3288.c
index baa5aebd3277..11493f0be2b1 100644
--- a/drivers/clk/rockchip/clk-rk3288.c
+++ b/drivers/clk/rockchip/clk-rk3288.c
@@ -195,10 +195,14 @@ PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr" };
 PNAME(mux_aclk_cpu_src_p)	= { "cpll_aclk_cpu", "gpll_aclk_cpu" };
 
 PNAME(mux_pll_src_cpll_gpll_p)		= { "cpll", "gpll" };
-PNAME(mux_pll_src_npll_cpll_gpll_p)	= { "npll", "cpll", "gpll" };
-PNAME(mux_pll_src_cpll_gpll_npll_p)	= { "cpll", "gpll", "npll" };
+PNAME_ED(mux_pll_src_npll_cpll_gpll_p)	= { "npll", "cpll", "gpll" };
+
+PNAME_ED(mux_pll_src_cgn_pll_nonvop_p)	= { "cpll", "gpll", "npll" };
+PNAME_ED(mux_pll_src_cgn_pll_vop0_p) = { "cpll", "gpll", "npll" };
+PNAME_ED(mux_pll_src_cgn_pll_vop1_p) = { "cpll", "gpll", "npll" };
+
 PNAME(mux_pll_src_cpll_gpll_usb480m_p)	= { "cpll", "gpll", "unstable:usbphy480m_src" };
-PNAME(mux_pll_src_cpll_gll_usb_npll_p)	= { "cpll", "gpll", "unstable:usbphy480m_src", "npll" };
+PNAME_ED(mux_pll_src_cpll_gll_usb_npll_p) = { "cpll", "gpll", "unstable:usbphy480m_src", "npll" };
 
 PNAME(mux_mmc_src_p)	= { "cpll", "gpll", "xin24m", "xin24m" };
 PNAME(mux_i2s_pre_p)	= { "i2s_src", "i2s_frac", "ext_i2s", "xin12m" };
@@ -442,24 +446,24 @@ static struct rockchip_clk_branch rk3288_clk_branches[] __initdata = {
 			RK3288_CLKSEL_CON(30), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(3), 4, GFLAGS),
 
-	COMPOSITE(DCLK_VOP0, "dclk_vop0", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(DCLK_VOP0, "dclk_vop0", mux_pll_src_cgn_pll_vop0_p, 0,
 			RK3288_CLKSEL_CON(27), 0, 2, MFLAGS, 8, 8, DFLAGS,
 			RK3288_CLKGATE_CON(3), 1, GFLAGS),
-	COMPOSITE(DCLK_VOP1, "dclk_vop1", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(DCLK_VOP1, "dclk_vop1", mux_pll_src_cgn_pll_vop1_p, 0,
 			RK3288_CLKSEL_CON(29), 6, 2, MFLAGS, 8, 8, DFLAGS,
 			RK3288_CLKGATE_CON(3), 3, GFLAGS),
 
 	COMPOSITE_NODIV(SCLK_EDP_24M, "sclk_edp_24m", mux_edp_24m_p, 0,
 			RK3288_CLKSEL_CON(28), 15, 1, MFLAGS,
 			RK3288_CLKGATE_CON(3), 12, GFLAGS),
-	COMPOSITE(SCLK_EDP, "sclk_edp", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_EDP, "sclk_edp", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(28), 6, 2, MFLAGS, 0, 6, DFLAGS,
 			RK3288_CLKGATE_CON(3), 13, GFLAGS),
 
-	COMPOSITE(SCLK_ISP, "sclk_isp", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_ISP, "sclk_isp", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(6), 6, 2, MFLAGS, 0, 6, DFLAGS,
 			RK3288_CLKGATE_CON(3), 14, GFLAGS),
-	COMPOSITE(SCLK_ISP_JPE, "sclk_isp_jpe", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_ISP_JPE, "sclk_isp_jpe", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(6), 14, 2, MFLAGS, 8, 6, DFLAGS,
 			RK3288_CLKGATE_CON(3), 15, GFLAGS),
 
@@ -468,16 +472,16 @@ static struct rockchip_clk_branch rk3288_clk_branches[] __initdata = {
 	GATE(SCLK_HDMI_CEC, "sclk_hdmi_cec", "xin32k", 0,
 			RK3288_CLKGATE_CON(5), 11, GFLAGS),
 
-	COMPOSITE(ACLK_HEVC, "aclk_hevc", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(ACLK_HEVC, "aclk_hevc", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(39), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(13), 13, GFLAGS),
 	DIV(HCLK_HEVC, "hclk_hevc", "aclk_hevc", 0,
 			RK3288_CLKSEL_CON(40), 12, 2, DFLAGS),
 
-	COMPOSITE(SCLK_HEVC_CABAC, "sclk_hevc_cabac", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_HEVC_CABAC, "sclk_hevc_cabac", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(42), 6, 2, MFLAGS, 0, 5, DFLAGS,
 			RK3288_CLKGATE_CON(13), 14, GFLAGS),
-	COMPOSITE(SCLK_HEVC_CORE, "sclk_hevc_core", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(SCLK_HEVC_CORE, "sclk_hevc_core", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(42), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(13), 15, GFLAGS),
 
@@ -551,7 +555,7 @@ static struct rockchip_clk_branch rk3288_clk_branches[] __initdata = {
 	COMPOSITE(0, "sclk_tspout", mux_tspout_p, 0,
 			RK3288_CLKSEL_CON(35), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(4), 11, GFLAGS),
-	COMPOSITE(0, "sclk_tsp", mux_pll_src_cpll_gpll_npll_p, 0,
+	COMPOSITE(0, "sclk_tsp", mux_pll_src_cgn_pll_nonvop_p, 0,
 			RK3288_CLKSEL_CON(35), 6, 2, MFLAGS, 0, 5, DFLAGS,
 			RK3288_CLKGATE_CON(4), 10, GFLAGS),
 
@@ -932,6 +936,7 @@ static void __init rk3288_common_init(struct device_node *np,
 				      enum rk3288_variant soc)
 {
 	struct rockchip_clk_provider *ctx;
+	s32 npll_vop = -1;
 
 	rk3288_cru_base = of_iomap(np, 0);
 	if (!rk3288_cru_base) {
@@ -939,6 +944,46 @@ static void __init rk3288_common_init(struct device_node *np,
 		return;
 	}
 
+	if (!of_property_read_s32(np, "rockchip,npll-for-vop", &npll_vop)) {
+		if ((npll_vop < -1) || (npll_vop > 1)) {
+			pr_warn("%s: invalid VOP to dedicate NPLL to: %d\n",
+				__func__, npll_vop);
+		} else if (npll_vop >= 0) {
+			unsigned int vop_clk_id;
+			const char ** npll_names;
+			const char ** non_npll_names;
+			int i;
+
+			/* Firstly, not-VOP needs to not use npll */
+			mux_pll_src_npll_cpll_gpll_p[0] = "dummy_npll";
+			mux_pll_src_cgn_pll_nonvop_p[2] = "dummy_npll";
+			mux_pll_src_cpll_gll_usb_npll_p[3] = "dummy_npll";
+
+			/* Then the npll VOP needs to only use npll, and the other one not use npll. */
+			if (npll_vop) {
+				vop_clk_id = DCLK_VOP1;
+				npll_names = mux_pll_src_cgn_pll_vop1_p;
+				non_npll_names = mux_pll_src_cgn_pll_vop0_p;
+			} else {
+				vop_clk_id = DCLK_VOP0;
+				npll_names = mux_pll_src_cgn_pll_vop0_p;
+				non_npll_names = mux_pll_src_cgn_pll_vop1_p;
+			}
+			npll_names[0] = "dummy_cpll";
+			npll_names[1] = "dummy_gpll";
+			non_npll_names[2] = "dummy_npll";
+
+			/* Lastly the npll-dedicated-VOP needs to be able to control npll. */
+			for (i = 0; i < ARRAY_SIZE(rk3288_clk_branches); i++) {
+				if (rk3288_clk_branches[i].id == vop_clk_id) {
+					rk3288_clk_branches[i].flags |= CLK_SET_RATE_PARENT;
+					break;
+				}
+			}
+			pr_debug("%s: npll dedicated for VOP %d\n", __func__, npll_vop);
+		}
+	}
+
 	ctx = rockchip_clk_init(np, rk3288_cru_base, CLK_NR_CLKS);
 	if (IS_ERR(ctx)) {
 		pr_err("%s: rockchip clk init failed\n", __func__);
diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
index 758ebaf2236b..7ee324e4186f 100644
--- a/drivers/clk/rockchip/clk.h
+++ b/drivers/clk/rockchip/clk.h
@@ -510,6 +510,9 @@ struct clk *rockchip_clk_register_muxgrf(const char *name,
 
 #define PNAME(x) static const char *const x[] __initconst
 
+/* For when you want to be able to modify the pointers. */
+#define PNAME_ED(x) static const char * x[] __initdata
+
 enum rockchip_clk_branch_type {
 	branch_composite,
 	branch_mux,
-- 
2.49.0


From ab0afee8dfcb505284e1eaa8a85e499c75163b75 Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Wed, 22 Aug 2018 18:36:40 +0000
Subject: [PATCH 02/15] drm: dw_hdmi-rockchip: better clock selection logic and
 dts-based rate list

This contains traces of the following commits from the ChromeOS 3.14
tree, which improve RF/EMI performance and detach the clock selection
logic from the HDMI PHY configurations, plus support for configuring
the allowed clock rates via device tree as they are dependent on
PLL configuration and maybe even the PCB layout and other hardware things,
eg. interference to wifi or such (EMI).

Rates that were allowed previous to this patch are added as the fallback
list if no dts configuration exists.

CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Adjust rockchip_mpll_cfg for 146.25
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: expand the informal mpll config
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: add slop to more tables
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: redo rockchip hdmi to allow slop
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Use auto-generated tables
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Fixup the clock to be what we expect
CHROMIUM: drm/rockchip: hdmi: adjust cklvl & txlvl for RF/EMI
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Set cur_ctr to 0 always
CHROMIUM: drm: rockchip/dw_hdmi-rockchip: Decrease slop

Signed-off-by: Urja Rannikko <urjaman@gmail.com>
Signed-off-by: Maya Matuszczyk <maccraft123mc@gmail.com>
---
 drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c | 279 ++++++++++++--------
 1 file changed, 166 insertions(+), 113 deletions(-)

diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index aae48e906af1..81f8a82aa5d4 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -80,8 +80,13 @@ struct rockchip_hdmi {
 	struct regulator *avdd_0v9;
 	struct regulator *avdd_1v8;
 	struct phy *phy;
+	u32* rates;
+	u32 rates_cnt;
 };
 
+#define CLK_SLOP(clk)          ((clk) / 1000)
+#define CLK_PLUS_SLOP(clk)     ((clk) + CLK_SLOP(clk))
+
 static struct rockchip_hdmi *to_rockchip_hdmi(struct drm_encoder *encoder)
 {
 	struct rockchip_encoder *rkencoder = to_rockchip_encoder(encoder);
@@ -89,126 +94,132 @@ static struct rockchip_hdmi *to_rockchip_hdmi(struct drm_encoder *encoder)
 	return container_of(rkencoder, struct rockchip_hdmi, encoder);
 }
 
+/* These were the rates allowed by the driver before rates list in device tree,
+ * so keep them around as a fallback */
+static const u32 dw_hdmi_fallback_rates[] = {
+	27000000,
+	36000000,
+	40000000,
+	54000000,
+	65000000,
+	66000000,
+	74250000,
+	83500000,
+	106500000,
+	108000000,
+	146250000,
+	148500000
+};
+
 static const struct dw_hdmi_mpll_config rockchip_mpll_cfg[] = {
 	{
-		27000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
+		30666000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40f3, 0x0000 },
 		},
-	}, {
-		36000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
-		},
-	}, {
-		40000000, {
-			{ 0x00b3, 0x0000},
-			{ 0x2153, 0x0000},
-			{ 0x40f3, 0x0000}
+	},  {
+		36800000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		54000000, {
-			{ 0x0072, 0x0001},
-			{ 0x2142, 0x0001},
-			{ 0x40a2, 0x0001},
+	},  {
+		46000000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		65000000, {
-			{ 0x0072, 0x0001},
-			{ 0x2142, 0x0001},
-			{ 0x40a2, 0x0001},
+	},  {
+		61333000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
 		},
-	}, {
-		66000000, {
-			{ 0x013e, 0x0003},
-			{ 0x217e, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		73600000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		74250000, {
-			{ 0x0072, 0x0001},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		92000000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		83500000, {
-			{ 0x0072, 0x0001},
+	},  {
+		122666000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
 		},
-	}, {
-		108000000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		147200000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		106500000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		184000000, {
+			{ 0x0051, 0x0002 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		146250000, {
-			{ 0x0051, 0x0002},
-			{ 0x2145, 0x0002},
-			{ 0x4061, 0x0002}
+	},  {
+		226666000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
 		},
-	}, {
-		148500000, {
-			{ 0x0051, 0x0003},
-			{ 0x214c, 0x0003},
-			{ 0x4064, 0x0003}
+	},  {
+		272000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x5a64, 0x0003 },
 		},
-	}, {
+	},  {
 		340000000, {
 			{ 0x0040, 0x0003 },
 			{ 0x3b4c, 0x0003 },
 			{ 0x5a64, 0x0003 },
 		},
-	}, {
+	},  {
+		600000000, {
+			{ 0x1a40, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	},  {
 		~0UL, {
-			{ 0x00a0, 0x000a },
-			{ 0x2001, 0x000f },
-			{ 0x4002, 0x000f },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
 		},
 	}
 };
 
 static const struct dw_hdmi_curr_ctrl rockchip_cur_ctr[] = {
-	/*      pixelclk    bpp8    bpp10   bpp12 */
+	/*      pixelclk      bpp8    bpp10   bpp12 */
 	{
-		40000000,  { 0x0018, 0x0018, 0x0018 },
-	}, {
-		65000000,  { 0x0028, 0x0028, 0x0028 },
+		600000000,  { 0x0000, 0x0000, 0x0000 },
 	}, {
-		66000000,  { 0x0038, 0x0038, 0x0038 },
-	}, {
-		74250000,  { 0x0028, 0x0038, 0x0038 },
-	}, {
-		83500000,  { 0x0028, 0x0038, 0x0038 },
-	}, {
-		146250000, { 0x0038, 0x0038, 0x0038 },
-	}, {
-		148500000, { 0x0000, 0x0038, 0x0038 },
-	}, {
-		600000000, { 0x0000, 0x0000, 0x0000 },
-	}, {
-		~0UL,      { 0x0000, 0x0000, 0x0000},
+		~0UL,       { 0x0000, 0x0000, 0x0000},
 	}
 };
 
 static const struct dw_hdmi_phy_config rockchip_phy_config[] = {
-	/*pixelclk   symbol   term   vlev*/
-	{ 74250000,  0x8009, 0x0004, 0x0272},
-	{ 148500000, 0x802b, 0x0004, 0x028d},
-	{ 297000000, 0x8039, 0x0005, 0x028d},
-	{ ~0UL,	     0x0000, 0x0000, 0x0000}
+	/*pixelclk		    symbol  term    vlev*/
+	{ CLK_PLUS_SLOP(74250000),  0x8009, 0x0004, 0x0272},
+	{ CLK_PLUS_SLOP(165000000), 0x802b, 0x0004, 0x0209},
+	{ CLK_PLUS_SLOP(297000000), 0x8039, 0x0005, 0x028d},
+	{ ~0UL,                     0x0000, 0x0000, 0x0000}
 };
 
 static int rockchip_hdmi_parse_dt(struct rockchip_hdmi *hdmi)
 {
 	struct device_node *np = hdmi->dev->of_node;
+	int rates_cnt;
 
 	hdmi->regmap = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
 	if (IS_ERR(hdmi->regmap)) {
@@ -245,39 +256,51 @@ static int rockchip_hdmi_parse_dt(struct rockchip_hdmi *hdmi)
 	if (IS_ERR(hdmi->avdd_1v8))
 		return PTR_ERR(hdmi->avdd_1v8);
 
+	if ((rates_cnt = of_property_count_u32_elems(np, "rockchip,hdmi-rates-hz")) > 0) {
+		int rv;
+		u32 *rates = devm_kmalloc_array(hdmi->dev, rates_cnt, sizeof(u32), GFP_KERNEL);
+		if (!rates)
+			return -ENOMEM;
+		rv = of_property_read_u32_array(np, "rockchip,hdmi-rates-hz", rates, rates_cnt);
+		if (rv)
+			return rv;
+		hdmi->rates = rates;
+		hdmi->rates_cnt = rates_cnt;
+	} else {
+		rates_cnt = ARRAY_SIZE(dw_hdmi_fallback_rates);
+		hdmi->rates = devm_kmalloc_array(hdmi->dev, rates_cnt, sizeof(u32), GFP_KERNEL);
+		if (!hdmi->rates)
+			return -ENOMEM;
+		memcpy(hdmi->rates, dw_hdmi_fallback_rates, rates_cnt * sizeof(u32));
+		hdmi->rates_cnt = rates_cnt;
+	}
+
+
 	return 0;
 }
 
 static enum drm_mode_status
-dw_hdmi_rockchip_mode_valid(struct dw_hdmi *dw_hdmi, void *data,
-			    const struct drm_display_info *info,
+dw_hdmi_rockchip_encoder_mode_valid(struct drm_encoder *encoder,
 			    const struct drm_display_mode *mode)
 {
-	struct rockchip_hdmi *hdmi = data;
-	const struct dw_hdmi_mpll_config *mpll_cfg = rockchip_mpll_cfg;
+	struct rockchip_hdmi *hdmi = to_rockchip_hdmi(encoder);
 	int pclk = mode->clock * 1000;
-	bool exact_match = hdmi->plat_data->phy_force_vendor;
+	int num_rates = hdmi->rates_cnt;
 	int i;
 
-	if (hdmi->ref_clk) {
-		int rpclk = clk_round_rate(hdmi->ref_clk, pclk);
+	/*
+	 * Pixel clocks we support are always < 2GHz and so fit in an
+	 * int.  We should make sure source rate does too so we don't get
+	 * overflow when we multiply by 1000.
+	 */
+	if (mode->clock > INT_MAX / 1000)
+		return MODE_BAD;
 
-		if (abs(rpclk - pclk) > pclk / 1000)
-			return MODE_NOCLOCK;
-	}
+	for (i = 0; i < num_rates; i++) {
+		int slop = CLK_SLOP(pclk);
 
-	for (i = 0; mpll_cfg[i].mpixelclock != (~0UL); i++) {
-		/*
-		 * For vendor specific phys force an exact match of the pixelclock
-		 * to preserve the original behaviour of the driver.
-		 */
-		if (exact_match && pclk == mpll_cfg[i].mpixelclock)
-			return MODE_OK;
-		/*
-		 * The Synopsys phy can work with pixelclocks up to the value given
-		 * in the corresponding mpll_cfg entry.
-		 */
-		if (!exact_match && pclk <= mpll_cfg[i].mpixelclock)
+		if ((pclk >= hdmi->rates[i] - slop) &&
+		    (pclk <= hdmi->rates[i] + slop))
 			return MODE_OK;
 	}
 
@@ -293,7 +316,39 @@ dw_hdmi_rockchip_encoder_mode_fixup(struct drm_encoder *encoder,
 				    const struct drm_display_mode *mode,
 				    struct drm_display_mode *adj_mode)
 {
-	return true;
+	struct rockchip_hdmi *hdmi = to_rockchip_hdmi(encoder);
+	int pclk = adj_mode->clock * 1000;
+	int best_diff = INT_MAX;
+	int best_clock = 0;
+	int slop;
+	int i;
+
+	/* Pick the best clock */
+	for (i = 0; i < hdmi->rates_cnt; i++) {
+		int diff = hdmi->rates[i] - pclk;
+
+		if (diff < 0)
+			diff = -diff;
+		if (diff < best_diff) {
+			best_diff = diff;
+			best_clock = hdmi->rates[i];
+
+			/* Bail early if we're exact */
+			if (best_diff == 0)
+				return true;
+		}
+	}
+
+	/* Double check that it's OK */
+	slop = CLK_SLOP(pclk);
+	if ((pclk >= best_clock - slop) && (pclk <= best_clock + slop)) {
+		adj_mode->clock = DIV_ROUND_UP(best_clock, 1000);
+		return true;
+	}
+
+	/* Shoudn't be here; we should have said rate wasn't valid */
+	dev_warn(hdmi->dev, "tried to set invalid rate %d\n", adj_mode->clock);
+	return false;
 }
 
 static void dw_hdmi_rockchip_encoder_mode_set(struct drm_encoder *encoder,
@@ -349,6 +404,7 @@ dw_hdmi_rockchip_encoder_atomic_check(struct drm_encoder *encoder,
 }
 
 static const struct drm_encoder_helper_funcs dw_hdmi_rockchip_encoder_helper_funcs = {
+	.mode_valid = dw_hdmi_rockchip_encoder_mode_valid,
 	.mode_fixup = dw_hdmi_rockchip_encoder_mode_fixup,
 	.mode_set   = dw_hdmi_rockchip_encoder_mode_set,
 	.enable     = dw_hdmi_rockchip_encoder_enable,
@@ -451,7 +507,6 @@ static struct rockchip_hdmi_chip_data rk3228_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3228_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg = rockchip_mpll_cfg,
 	.cur_ctr = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -468,7 +523,6 @@ static struct rockchip_hdmi_chip_data rk3288_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3288_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg   = rockchip_mpll_cfg,
 	.cur_ctr    = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -488,7 +542,6 @@ static struct rockchip_hdmi_chip_data rk3328_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3328_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg = rockchip_mpll_cfg,
 	.cur_ctr = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -506,7 +559,6 @@ static struct rockchip_hdmi_chip_data rk3399_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3399_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg   = rockchip_mpll_cfg,
 	.cur_ctr    = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -519,7 +571,6 @@ static struct rockchip_hdmi_chip_data rk3568_chip_data = {
 };
 
 static const struct dw_hdmi_plat_data rk3568_hdmi_drv_data = {
-	.mode_valid = dw_hdmi_rockchip_mode_valid,
 	.mpll_cfg   = rockchip_mpll_cfg,
 	.cur_ctr    = rockchip_cur_ctr,
 	.phy_config = rockchip_phy_config,
@@ -652,6 +703,7 @@ static int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,
 	return 0;
 
 err_bind:
+	devm_kfree(hdmi->dev, hdmi->rates);
 	drm_encoder_cleanup(encoder);
 	clk_disable_unprepare(hdmi->ref_clk);
 err_clk:
@@ -667,6 +719,7 @@ static void dw_hdmi_rockchip_unbind(struct device *dev, struct device *master,
 {
 	struct rockchip_hdmi *hdmi = dev_get_drvdata(dev);
 
+	devm_kfree(hdmi->dev, hdmi->rates);
 	dw_hdmi_unbind(hdmi->hdmi);
 	drm_encoder_cleanup(&hdmi->encoder.encoder);
 	clk_disable_unprepare(hdmi->ref_clk);
-- 
2.49.0


From 4e0d7e6163b93e7864406327dc53ec3ea4f0b201 Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Mon, 27 Aug 2018 19:00:50 +0000
Subject: [PATCH 03/15] dts: rk3288: support for dedicating npll to a vop

Add the VOP DCLKs to the assigned clocks list so their
parents can be set in the dts include files for
devices that do dedicate npll to a vop.

Signed-off-by: Urja Rannikko <urjaman@gmail.com>
---
 arch/arm/boot/dts/rockchip/rk3288.dtsi | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/rockchip/rk3288.dtsi b/arch/arm/boot/dts/rockchip/rk3288.dtsi
index 8593a8359937..1cfa4eda5abf 100644
--- a/arch/arm/boot/dts/rockchip/rk3288.dtsi
+++ b/arch/arm/boot/dts/rockchip/rk3288.dtsi
@@ -867,12 +867,14 @@
 		rockchip,grf = <&grf>;
 		#clock-cells = <1>;
 		#reset-cells = <1>;
-		assigned-clocks = <&cru PLL_GPLL>, <&cru PLL_CPLL>,
+		assigned-clocks = <&cru DCLK_VOP0>, <&cru DCLK_VOP1>,
+				  <&cru PLL_GPLL>, <&cru PLL_CPLL>,
 				  <&cru PLL_NPLL>, <&cru ACLK_CPU>,
 				  <&cru HCLK_CPU>, <&cru PCLK_CPU>,
 				  <&cru ACLK_PERI>, <&cru HCLK_PERI>,
 				  <&cru PCLK_PERI>;
-		assigned-clock-rates = <594000000>, <400000000>,
+		assigned-clock-rates = <0>, <0>,
+				       <594000000>, <400000000>,
 				       <500000000>, <300000000>,
 				       <150000000>, <75000000>,
 				       <300000000>, <150000000>,
-- 
2.49.0


From 8f73d0588bcd53c2d63ef5ab292a3fa666221b78 Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Mon, 27 Aug 2018 19:03:49 +0000
Subject: [PATCH 04/15] dts: rk3288-veyron-chromebook: dedicate npll to
 VOP0/HDMI + HDMI rates

This enables flexible HDMI rates on the rk3288 chromebooks so that they
actually work with displays (also others than a 1080p one) in the wild.

The frequency list matches what ChromeOS allows.

Signed-off-by: Urja Rannikko <urjaman@gmail.com>
---
 .../rockchip/rk3288-veyron-chromebook.dtsi    | 62 +++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/arch/arm/boot/dts/rockchip/rk3288-veyron-chromebook.dtsi b/arch/arm/boot/dts/rockchip/rk3288-veyron-chromebook.dtsi
index 092316be67f7..e4d5c0240657 100644
--- a/arch/arm/boot/dts/rockchip/rk3288-veyron-chromebook.dtsi
+++ b/arch/arm/boot/dts/rockchip/rk3288-veyron-chromebook.dtsi
@@ -83,6 +83,68 @@
 	};
 };
 
+&cru {
+	/* Dedicate NPLL for VOP0 / VOP_BIG for HDMI. */
+	rockchip,npll-for-vop = <0>;
+	/* The first assigned clocks are DCLK_VOP0 and DCLK_VOP1 */
+	assigned-clock-parents = <&cru PLL_NPLL>, <&cru PLL_GPLL>;
+};
+
+/* Delete the nodes that allow non-desirable VOP - connector links. That
+ * is the eDP cannot use vopb and HDMI cannot use vopl. */
+
+/delete-node/ &edp_in_vopb;
+/delete-node/ &vopb_out_edp;
+/delete-node/ &hdmi_in_vopl;
+/delete-node/ &vopl_out_hdmi;
+
+&hdmi {
+	/* These depend on NPLL being dedicated to HDMI use. */
+	rockchip,hdmi-rates-hz = <
+		25176471	/* for 25.175 MHz, 0.006% off */
+		25200000
+		27000000
+		28320000
+		30240000
+		31500000
+		32000000
+		33750000
+		36000000
+		40000000
+		49500000
+		50000000
+		54000000
+		57290323	/* for 57.284 MHz, .011 % off */
+		65000000
+		68250000
+		71000000
+		72000000
+		73250000
+		74250000
+		74437500	/* for 74.44 MHz, .003% off */
+		75000000
+		78750000
+		78800000
+		79500000
+		83500000
+		85500000
+		88750000
+		97750000
+		101000000
+		106500000
+		108000000
+		115500000
+		118666667	/* for 118.68 MHz, .011% off */
+		119000000
+		121714286	/* for 121.75 MHz, .029% off */
+		135000000
+		136800000	/* for 136.75 MHz, .037% off */
+		146250000
+		148500000
+		154000000
+		162000000 >;
+};
+
 &rk808 {
 	vcc11-supply = <&vcc_5v>;
 
-- 
2.49.0


From bb1a4f6d134c41bc49ebcaace530ec33a2ec106b Mon Sep 17 00:00:00 2001
From: SolidHal <hal@halemmerich.com>
Date: Sun, 21 Oct 2018 16:40:15 -0500
Subject: [PATCH 05/15] Added a second reset when having an issue reading the
 emmc.

The c201 emmc can be... touchy. Sometimes one full reset isn't
enough to get it into a wokring state if it found it's way into
a really bad state. Note that in my testing WITHOUT this patch,
this only happens about once in just over 1600 reboots.

--
Edited by Urja Rannikko to actually limit the retries to once,
and to apply to 4.20.
--

Signed-off-by: SolidHal <hal@halemmerich.com>
Signed-off-by: Urja Rannikko <urjaman@gmail.com>
---
 drivers/mmc/core/block.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c
index 3564a0f63c9c..fbfc5c628f14 100644
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@ -1028,6 +1028,7 @@ static unsigned int mmc_blk_data_timeout_ms(struct mmc_host *host,
 static int mmc_blk_reset(struct mmc_blk_data *md, struct mmc_host *host,
 			 int type)
 {
+	int retries = 1;
 	int err;
 	struct mmc_blk_data *main_md = dev_get_drvdata(&host->card->dev);
 
@@ -1035,7 +1036,14 @@ static int mmc_blk_reset(struct mmc_blk_data *md, struct mmc_host *host,
 		return -EEXIST;
 
 	md->reset_done |= type;
+retry:
 	err = mmc_hw_reset(host->card);
+
+	/* Retry once because the C201 eMMC can be touchy */
+	if ((err) && (retries--)) {
+		goto retry;
+	}
+
 	/*
 	 * A successful reset will leave the card in the main partition, but
 	 * upon failure it might not be, so set it to MMC_BLK_PART_INVALID
-- 
2.49.0


From bb433be494e955b99c12a3344a8765eb6a9d4bd3 Mon Sep 17 00:00:00 2001
From: "Miouyouyou (Myy)" <myy@miouyouyou.fr>
Date: Tue, 9 Oct 2018 22:01:07 +0200
Subject: [PATCH 06/15] block: partitions: efi: Ignore bizarre Chromebook GPT
 partitions

This patch is based on @SolidHal work here :
https://raw.githubusercontent.com/SolidHal/PrawnOS/master/resources/BuildResources/patches-tested/kernel/0001-block-partitions-efi-Add-support-for-IGNOREME-GPT-si.patch

Here's the initial commit message :

8<---

This patch adds support for a special GPT header signature marker (using
the string 'IGNOREME' instead of the spec's 'EFI PART'). This tells the
kernel to ignore this GPT completely and look at the other one instead.
Since the kernel always prefers the primary GPT anyway, all we really
need to do effectively is to check whether the primary GPT is marked
'IGNOREME' and force evaluation of the secondary one in that case.

Borrowed from the chrome os 3.14 kernel, the commit can be found here:
https://chromium.googlesource.com/chromiumos/third_party/kernel/+/abba28d0a1b7361da6e2023352e92687166ca30d

Also bundled in this commit
https://chromium.googlesource.com/chromiumos/third_party/kernel/+/bd0c62c7de0c8a63314b7955e5718d8f6192f9d2%5E%21/#F0
Which is a small compiler warning fix for the above patch

This patch fixes how the kernel detects and handles certain mmc
manufatures devices, and allows the partitions on the mmc to be bootable
and mountable.

>8---

Signed-off-by: Miouyouyou (Myy) <myy@miouyouyou.fr>
---
 block/partitions/efi.c | 33 +++++++++++++++++++++++----------
 block/partitions/efi.h |  3 ++-
 2 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/block/partitions/efi.c b/block/partitions/efi.c
index 7acba66eed48..087032a4705e 100644
--- a/block/partitions/efi.c
+++ b/block/partitions/efi.c
@@ -328,23 +328,34 @@ static gpt_header *alloc_read_gpt_header(struct parsed_partitions *state,
  * @lba: logical block address of the GPT header to test
  * @gpt: GPT header ptr, filled on return.
  * @ptes: PTEs ptr, filled on return.
+ * @ignored is filled on return with 1 if this is an IGNOREME GPT,
+ *     0 otherwise. May be NULL.
  *
  * Description: returns 1 if valid,  0 on error.
  * If valid, returns pointers to newly allocated GPT header and PTEs.
  */
 static int is_gpt_valid(struct parsed_partitions *state, u64 lba,
-			gpt_header **gpt, gpt_entry **ptes)
+			gpt_header **gpt, gpt_entry **ptes, int *ignored)
 {
 	u32 crc, origcrc;
 	u64 lastlba, pt_size;
 
+	if (ignored)
+		*ignored = 0;
 	if (!ptes)
 		return 0;
 	if (!(*gpt = alloc_read_gpt_header(state, lba)))
 		return 0;
 
 	/* Check the GUID Partition Table signature */
-	if (le64_to_cpu((*gpt)->signature) != GPT_HEADER_SIGNATURE) {
+
+	if (le64_to_cpu((*gpt)->signature) == GPT_HEADER_SIGNATURE_IGNORED) {
+		pr_debug("GUID Partition Table at LBA %llu marked IGNOREME\n",
+						(unsigned long long)lba);
+		if (ignored)
+			*ignored = 1;
+		goto fail;
+	} else if (le64_to_cpu((*gpt)->signature) != GPT_HEADER_SIGNATURE) {
 		pr_debug("GUID Partition Table Header signature is wrong:"
 			 "%lld != %lld\n",
 			 (unsigned long long)le64_to_cpu((*gpt)->signature),
@@ -581,7 +592,7 @@ compare_gpts(gpt_header *pgpt, gpt_header *agpt, u64 lastlba)
 static int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,
 			  gpt_entry **ptes)
 {
-	int good_pgpt = 0, good_agpt = 0, good_pmbr = 0;
+	int good_pgpt = 0, good_agpt = 0, good_pmbr = 0, pgpt_ignored = 0;
 	gpt_header *pgpt = NULL, *agpt = NULL;
 	gpt_entry *pptes = NULL, *aptes = NULL;
 	legacy_mbr *legacymbr;
@@ -613,13 +624,13 @@ static int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,
 	}
 
 	good_pgpt = is_gpt_valid(state, GPT_PRIMARY_PARTITION_TABLE_LBA,
-				 &pgpt, &pptes);
+			 &pgpt, &pptes, &pgpt_ignored);
         if (good_pgpt)
 		good_agpt = is_gpt_valid(state,
 					 le64_to_cpu(pgpt->alternate_lba),
-					 &agpt, &aptes);
-        if (!good_agpt && force_gpt)
-                good_agpt = is_gpt_valid(state, lastlba, &agpt, &aptes);
+					 &agpt, &aptes, NULL);
+	if (!good_agpt && (force_gpt || pgpt_ignored))
+		good_agpt = is_gpt_valid(state, lastlba, &agpt, &aptes, NULL);
 
 	if (!good_agpt && force_gpt && fops->alternative_gpt_sector) {
 		sector_t agpt_sector;
@@ -628,14 +639,15 @@ static int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,
 		err = fops->alternative_gpt_sector(disk, &agpt_sector);
 		if (!err)
 			good_agpt = is_gpt_valid(state, agpt_sector,
-						 &agpt, &aptes);
+						 &agpt, &aptes, NULL);
 	}
 
         /* The obviously unsuccessful case */
         if (!good_pgpt && !good_agpt)
                 goto fail;
 
-        compare_gpts(pgpt, agpt, lastlba);
+	if (!pgpt_ignored)
+		compare_gpts(pgpt, agpt, lastlba);
 
         /* The good cases */
         if (good_pgpt) {
@@ -652,7 +664,8 @@ static int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,
                 *ptes = aptes;
                 kfree(pgpt);
                 kfree(pptes);
-		pr_warn("Primary GPT is invalid, using alternate GPT.\n");
+	pr_warn("Primary GPT is %s, using alternate GPT.\n",
+		pgpt_ignored ? "being ignored" : "invalid");
                 return 1;
         }
 
diff --git a/block/partitions/efi.h b/block/partitions/efi.h
index 84b9f36b9e47..09726227e891 100644
--- a/block/partitions/efi.h
+++ b/block/partitions/efi.h
@@ -26,7 +26,8 @@
 #define GPT_MBR_PROTECTIVE  1
 #define GPT_MBR_HYBRID      2
 
-#define GPT_HEADER_SIGNATURE 0x5452415020494645ULL
+#define GPT_HEADER_SIGNATURE		0x5452415020494645ULL	/* 'EFI PART' */
+#define GPT_HEADER_SIGNATURE_IGNORED	0x454d45524f4e4749ULL	/* 'IGNOREME' */
 #define GPT_HEADER_REVISION_V1 0x00010000
 #define GPT_PRIMARY_PARTITION_TABLE_LBA 1
 
-- 
2.49.0


From 52a9d1101d605423bcc0555743755e8d2b4e9d0e Mon Sep 17 00:00:00 2001
From: "Miouyouyou (Myy)" <myy@miouyouyou.fr>
Date: Tue, 30 Oct 2018 22:44:54 +0100
Subject: [PATCH 07/15] mmc: Added a flag to disable cache flush during reset

The ASUS Chromebook suffer from 10 minutes long hang, when trying
to flush the cache of the eMMC, in order to recover from eMMC init
issues when booting the system.

A new flag "no-recovery-cache-flush" whose purpose is to disable
cache flush during recovery reset, has been added.

This work is adapted from @SolidHal work, which is available here :
https://github.com/SolidHal/PrawnOS/blob/develop-4.19/resources/BuildResources/patches-tested/kernel/Don-t-try-to-flush-cache-on-reset.patch

Signed-off-by: Miouyouyou (Myy) <myy@miouyouyou.fr>
---
 drivers/mmc/core/host.c  |  2 ++
 drivers/mmc/core/mmc.c   | 18 ++++++++++++++----
 include/linux/mmc/host.h |  1 +
 3 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index cf396e8f34e9..135cba5d5aa3 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -409,6 +409,8 @@ int mmc_of_parse(struct mmc_host *host)
 	if (device_property_read_bool(dev, "no-mmc-hs400"))
 		host->caps2 &= ~(MMC_CAP2_HS400_1_8V | MMC_CAP2_HS400_1_2V |
 				 MMC_CAP2_HS400_ES);
+	if (device_property_read_bool(dev, "no-recovery-cache-flush"))
+		host->caps2 |= MMC_CAP2_NO_RECOVERY_CACHE_FLUSH;
 
 	/* Must be after "non-removable" check */
 	if (device_property_read_u32(dev, "fixed-emmc-driver-type", &drv_type) == 0) {
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 7e39017e440f..a8406756299d 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -2238,6 +2238,12 @@ static int mmc_runtime_resume(struct mmc_host *host)
 	return 0;
 }
 
+static inline int mmc_can_flush_during_recovery(
+	struct mmc_host *host)
+{
+	return (host->caps2 & MMC_CAP2_NO_RECOVERY_CACHE_FLUSH) == 0;
+}
+
 static int mmc_can_reset(struct mmc_card *card)
 {
 	u8 rst_n_function;
@@ -2252,11 +2258,15 @@ static int _mmc_hw_reset(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
 
-	/*
-	 * In the case of recovery, we can't expect flushing the cache to work
-	 * always, but we have a go and ignore errors.
+	/* Using a "Cache flush" during recovery events seems...
+	 * "dubious" at best, and generate significant issues on
+	 * some platforms, like 10 minutes hang up, at worst.
+	 * I'm keeping this line because the old code did it but...
+	 * feel free to double check if that's needed at all.
 	 */
-	_mmc_flush_cache(host);
+
+	if (mmc_can_flush_during_recovery(host))
+		_mmc_flush_cache(host);
 
 	if ((host->caps & MMC_CAP_HW_RESET) && host->ops->card_hw_reset &&
 	     mmc_can_reset(card)) {
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 62a6847a3b6f..d80cc06fa2c6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -427,6 +427,7 @@ struct mmc_host {
 #define MMC_CAP2_CRYPTO		0
 #endif
 #define MMC_CAP2_ALT_GPT_TEGRA	(1 << 28)	/* Host with eMMC that has GPT entry at a non-standard location */
+#define MMC_CAP2_NO_RECOVERY_CACHE_FLUSH	(1 << 29)	/* Do not flush the device cache when recovering */
 
 	int			fixed_drv_type;	/* fixed driver type for non-removable media */
 
-- 
2.49.0


From 517f2ef8f40aab950d903d61918ea76ab34f56b5 Mon Sep 17 00:00:00 2001
From: "Miouyouyou (Myy)" <myy@miouyouyou.fr>
Date: Thu, 1 Nov 2018 21:31:26 +0100
Subject: [PATCH 08/15] arm: dts: veyron: Added a flag to disable cache flush
 during reset

Flushing the MMC cache of ASUS Chromebooks during initialization or
"recovery" generates 10 minutes hangup, according to @SolidHal.

This is an adaptation of @SolidHal, in order to pinpoint the fix to
Veyron Chromebooks, and avoiding issues other RK3288 boards.

Signed-off-by: Miouyouyou (Myy) <myy@miouyouyou.fr>
---
 arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi b/arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi
index d838bf0d5d9a..7aeb70e9b828 100644
--- a/arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi
+++ b/arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi
@@ -157,6 +157,7 @@
 	mmc-hs200-1_8v;
 	mmc-pwrseq = <&emmc_pwrseq>;
 	non-removable;
+	no-recovery-cache-flush;
 	pinctrl-names = "default";
 	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
 };
-- 
2.49.0


From bf014d40059d4454edf3ee80168df72393594a9d Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Mon, 18 Mar 2019 22:40:52 +0000
Subject: [PATCH 09/15] dwc2 veyron otg mode hack

---
 arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi |  2 +-
 drivers/usb/dwc2/core.c                       |  2 +-
 drivers/usb/dwc2/core.h                       |  1 +
 drivers/usb/dwc2/debugfs.c                    | 50 +++++++++++++++++++
 drivers/usb/dwc2/platform.c                   |  2 +
 5 files changed, 55 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi b/arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi
index 7aeb70e9b828..3d4efa544fce 100644
--- a/arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi
+++ b/arch/arm/boot/dts/rockchip/rk3288-veyron.dtsi
@@ -440,8 +440,8 @@
 
 	assigned-clocks = <&cru SCLK_USBPHY480M_SRC>;
 	assigned-clock-parents = <&usbphy0>;
-	dr_mode = "host";
 	snps,need-phy-for-wake;
+	/* dr_mode = "host"; */
 };
 
 &vopb {
diff --git a/drivers/usb/dwc2/core.c b/drivers/usb/dwc2/core.c
index 5635e4d7ec88..58b864d0aaea 100644
--- a/drivers/usb/dwc2/core.c
+++ b/drivers/usb/dwc2/core.c
@@ -547,7 +547,7 @@ void dwc2_force_mode(struct dwc2_hsotg *hsotg, bool host)
  *
  * @hsotg: Programming view of DWC_otg controller
  */
-static void dwc2_clear_force_mode(struct dwc2_hsotg *hsotg)
+void dwc2_clear_force_mode(struct dwc2_hsotg *hsotg)
 {
 	u32 gusbcfg;
 
diff --git a/drivers/usb/dwc2/core.h b/drivers/usb/dwc2/core.h
index a141f83aba0c..97bc2297456f 100644
--- a/drivers/usb/dwc2/core.h
+++ b/drivers/usb/dwc2/core.h
@@ -1313,6 +1313,7 @@ int dwc2_phy_init(struct dwc2_hsotg *hsotg, bool select_phy);
 
 void dwc2_force_mode(struct dwc2_hsotg *hsotg, bool host);
 void dwc2_force_dr_mode(struct dwc2_hsotg *hsotg);
+void dwc2_clear_force_mode(struct dwc2_hsotg *hsotg);
 
 bool dwc2_is_controller_alive(struct dwc2_hsotg *hsotg);
 
diff --git a/drivers/usb/dwc2/debugfs.c b/drivers/usb/dwc2/debugfs.c
index 1d72ece9cfe4..3e0a09c14c97 100644
--- a/drivers/usb/dwc2/debugfs.c
+++ b/drivers/usb/dwc2/debugfs.c
@@ -114,6 +114,55 @@ static const struct file_operations testmode_fops = {
 	.release	= single_release,
 };
 
+static ssize_t cur_mode_write(struct file *file, const char __user *ubuf, size_t
+		count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct dwc2_hsotg	*hsotg = s->private;
+	int mode = 0;
+	char			buf[32];
+
+	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
+		return -EFAULT;
+
+	if (!strncmp(buf, "device", 6))
+		mode = 1;
+	else if (!strncmp(buf, "host", 4))
+		mode = 2;
+	else
+		mode = 0; /* otg/clear */
+
+	dwc2_clear_force_mode(hsotg);
+	switch (mode) {
+		case 1: dwc2_force_mode(hsotg, false); break;
+		case 2: dwc2_force_mode(hsotg, true); break;
+	}
+	return count;
+}
+
+
+static int cur_mode_show(struct seq_file *s, void *unused)
+{
+	struct dwc2_hsotg *hsotg = s->private;
+	seq_puts(s, dwc2_is_device_mode(hsotg) ? "device\n" : "host\n");
+	return 0;
+}
+
+
+static int cur_mode_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cur_mode_show, inode->i_private);
+}
+
+static const struct file_operations cur_mode_fops = {
+	.owner		= THIS_MODULE,
+	.open		= cur_mode_open,
+	.write		= cur_mode_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 /**
  * state_show - debugfs: show overall driver and device state.
  * @seq: The seq file to write to.
@@ -300,6 +349,7 @@ static void dwc2_hsotg_create_debug(struct dwc2_hsotg *hsotg)
 	debugfs_create_file("state", 0444, root, hsotg, &state_fops);
 	debugfs_create_file("testmode", 0644, root, hsotg, &testmode_fops);
 	debugfs_create_file("fifo", 0444, root, hsotg, &fifo_fops);
+	debugfs_create_file("cur_mode", 0644, root, hsotg, &cur_mode_fops);
 
 	/* Create one file for each out endpoint */
 	for (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {
diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index c1b7209b9483..6710c401d9a6 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -532,6 +532,8 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	 * other time after this.
 	 */
 	dwc2_force_dr_mode(hsotg);
+	/* HACK: Always start in host mode, even if you think you're an otg device :P */
+	dwc2_force_mode(hsotg, true);
 
 	retval = dwc2_init_params(hsotg);
 	if (retval)
-- 
2.49.0


From 99fdafdce042fdccde81b9b6cee623edc8c6fe78 Mon Sep 17 00:00:00 2001
From: Hal Emmerich <hal@halemmerich.com>
Date: Wed, 21 Aug 2019 16:52:41 -0500
Subject: [PATCH 10/15] Fix ath9k dwc2 init frame overruns

[ by Urja Rannikko: changed to log message to something more sensible. ]

This is a workaround for ar9271 drvices using the open ath9k firmware
With the dwc2 usb driver these endpoints end up throwing piles of
frame overrun errors and prevent the ath9k firmware from communicating
properly with the c201

This fix elongates the microframes by 4 so the dwc2 and ath9k devices
communicate properly. In my testing this did not impact network speeds.
---
 drivers/usb/dwc2/hcd_queue.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/drivers/usb/dwc2/hcd_queue.c b/drivers/usb/dwc2/hcd_queue.c
index 0d4495c6b9f7..3444cfd35840 100644
--- a/drivers/usb/dwc2/hcd_queue.c
+++ b/drivers/usb/dwc2/hcd_queue.c
@@ -1528,6 +1528,16 @@ static void dwc2_qh_init(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,
 			device_ns += dwc_tt->usb_tt->think_time;
 		qh->device_us = NS_TO_US(device_ns);
 
+    //Only enable workaround for highspeed devices, since only low and full speed devices so split, we can just check split
+    //The packets that fail right after the firmware is transferred are on an interrupt ep so we can use that to further narrow it down
+    //The ath9k device has issues with ep 3 and ep4
+    if(!do_split && !ep_is_isoc && ep_is_int && (urb->pipe_info.ep_num == 3 || urb->pipe_info.ep_num == 4)){
+      if (urb->interval == 1){
+        urb->interval = 4;
+        dev_info(hsotg->dev, "ath9k workaround: set usb urb interval to %d\n", urb->interval);
+      }
+    }
+
 		qh->device_interval = urb->interval;
 		qh->host_interval = urb->interval * (do_split ? 8 : 1);
 
-- 
2.49.0


From 52306621562bb3156c2ba5ab584e97408a1ee88c Mon Sep 17 00:00:00 2001
From: barzur <boris@konbu.org>
Date: Fri, 12 Jul 2019 11:33:32 +0900
Subject: [PATCH 11/15] usb/dwc2/hcd: channel halt may not be an error

Truncating the data was causing null pointer exceptions in memcpy,
let's be more careful.

Addendum by Urja Rannikko:

This was reported as a pull request on my linux github repo and it came
with this reproducer & notes:
-- begin --
I sometimes get kernel oops when USB tethering.
Here is how to repro:
* create high load on the CPU: I build a kernel with -j6;
* saturate your cdc_ether connection to the phone (I use netcat on both sides
  to do so, with termux on android);

I tracked down the issue to buffers getting truncated, the driver extracting
a target address from the end of the buffer (weird) & memcpy to a non validated
address.

I've fixed it by validating the address we write to & stopped treating
un-explained channel closure as errors. I guess the channel is closed due to a
timeout (maybe?), caused by heavy context switching on the machine.

I've been testing the following patch for ~1 week and it seems to work well.
-- end --

I do not have a suitable phone to reproduce this with so I cant personally
say if it works and I dont 100% understand it, but I looked at the patch
and I think it looks okay-ish (tho maybe should be two patches), so in the
meantime I'm including it here.
---
 drivers/usb/dwc2/hcd.c      | 3 ++-
 drivers/usb/dwc2/hcd_intr.c | 3 ++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c
index c1de38de2806..79ad20b3f863 100644
--- a/drivers/usb/dwc2/hcd.c
+++ b/drivers/usb/dwc2/hcd.c
@@ -2457,7 +2457,8 @@ static void dwc2_free_dma_aligned_buffer(struct urb *urb)
 		else
 			length = urb->actual_length;
 
-		memcpy(stored_xfer_buffer, urb->transfer_buffer, length);
+		if (stored_xfer_buffer)
+			memcpy(stored_xfer_buffer, urb->transfer_buffer, length);
 	}
 	kfree(urb->transfer_buffer);
 	urb->transfer_buffer = stored_xfer_buffer;
diff --git a/drivers/usb/dwc2/hcd_intr.c b/drivers/usb/dwc2/hcd_intr.c
index 5c7538d498dd..96dc5d8115d2 100644
--- a/drivers/usb/dwc2/hcd_intr.c
+++ b/drivers/usb/dwc2/hcd_intr.c
@@ -1935,7 +1935,8 @@ static void dwc2_hc_chhltd_intr_dma(struct dwc2_hsotg *hsotg,
 					"hcint 0x%08x, intsts 0x%08x\n",
 					chan->hcint,
 					dwc2_readl(hsotg, GINTSTS));
-				goto error;
+				dwc2_halt_channel(hsotg, chan, qtd,
+					DWC2_HC_XFER_PERIODIC_INCOMPLETE);
 			}
 		}
 	} else {
-- 
2.49.0


From cbdd259bb42f2141ed92f27523fd2cb2380d8c78 Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Tue, 8 Oct 2019 11:03:37 +0000
Subject: [PATCH 12/15] drm/panel: edp: Extend Innolux N116BGE mode info for
 ~60Hz from 74.25 Mhz

Signed-off-by: Urja Rannikko <urjaman@gmail.com>
---
 drivers/gpu/drm/panel/panel-edp.c | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-edp.c b/drivers/gpu/drm/panel/panel-edp.c
index 53b3b24d7d7c..dd6fdd3d4589 100644
--- a/drivers/gpu/drm/panel/panel-edp.c
+++ b/drivers/gpu/drm/panel/panel-edp.c
@@ -1309,16 +1309,25 @@ static const struct panel_desc innolux_n116bca_ea1 = {
  * porch, back porch, or sync length.  For now we'll leave a single setting
  * here which allows a bit of tweaking of the pixel clock at the expense of
  * refresh rate.
+ *
+ * Experimental testing with one panel suggests that the split among
+ * front/back/sync is not important, but the panel is not stable
+ * at htotal less than 1520 (atleast when running at 74.25 Mhz).
+ *
+ * There exists an experimental mode that gives very close to 60 Hz mode
+ * from 74.25 Mhz with htotal 1543 and vtotal 802 - we allow the
+ * hfront_porch and vback_porch to be adjusted to reach that mode.
+ *
  */
 static const struct display_timing innolux_n116bge_timing = {
 	.pixelclock = { 72600000, 76420000, 80240000 },
 	.hactive = { 1366, 1366, 1366 },
-	.hfront_porch = { 136, 136, 136 },
+	.hfront_porch = { 87, 136, 136 },
 	.hback_porch = { 60, 60, 60 },
 	.hsync_len = { 30, 30, 30 },
 	.vactive = { 768, 768, 768 },
 	.vfront_porch = { 8, 8, 8 },
-	.vback_porch = { 12, 12, 12 },
+	.vback_porch = { 12, 12, 14 },
 	.vsync_len = { 12, 12, 12 },
 	.flags = DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_HSYNC_LOW,
 };
-- 
2.49.0


From aa829aa286fbf27ef2bffe4a4296ed6c93e8f033 Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Tue, 8 Oct 2019 11:12:33 +0000
Subject: [PATCH 13/15] ARM: dts: rockchip: Adjust rk3288-veyron n116bge mode
 for ~60Hz

This is an experimental mode that gets very close to 60Hz (60.00067..)
from the available clock of 74.25Mhz on an rk3288. The mode
has htotal 1543 and vtotal 802.

Signed-off-by: Urja Rannikko <urjaman@gmail.com>
---
 arch/arm/boot/dts/rockchip/rk3288-veyron-edp.dtsi | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/rockchip/rk3288-veyron-edp.dtsi b/arch/arm/boot/dts/rockchip/rk3288-veyron-edp.dtsi
index 32c0f10765dd..ea20818202fc 100644
--- a/arch/arm/boot/dts/rockchip/rk3288-veyron-edp.dtsi
+++ b/arch/arm/boot/dts/rockchip/rk3288-veyron-edp.dtsi
@@ -62,13 +62,13 @@
 		panel-timing {
 			clock-frequency = <74250000>;
 			hactive = <1366>;
-			hfront-porch = <136>;
+			hfront-porch = <87>;
 			hback-porch = <60>;
 			hsync-len = <30>;
 			hsync-active = <0>;
 			vactive = <768>;
 			vfront-porch = <8>;
-			vback-porch = <12>;
+			vback-porch = <14>;
 			vsync-len = <12>;
 			vsync-active = <0>;
 		};
-- 
2.49.0


From f641b3a8f055fa05014c509065c57744ea177a79 Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Tue, 28 Sep 2021 20:23:13 +0300
Subject: [PATCH 14/15] Revert "clk: divider: Implement and wire up
 .determine_rate by default"

This reverts commit 69a00fb3d6970681c15a23595ec54233ce10295c.
That broke eMMC detection (error -110) on veyron speedy.
Why is still an open question but for now i'm doing this revert
in my tree to be able to test the rest of 5.15 rc's.
---
 drivers/clk/clk-divider.c | 23 -----------------------
 1 file changed, 23 deletions(-)

diff --git a/drivers/clk/clk-divider.c b/drivers/clk/clk-divider.c
index a2c2b5203b0a..9a63a0447d6f 100644
--- a/drivers/clk/clk-divider.c
+++ b/drivers/clk/clk-divider.c
@@ -446,27 +446,6 @@ static long clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,
 				  divider->width, divider->flags);
 }
 
-static int clk_divider_determine_rate(struct clk_hw *hw,
-				      struct clk_rate_request *req)
-{
-	struct clk_divider *divider = to_clk_divider(hw);
-
-	/* if read only, just return current value */
-	if (divider->flags & CLK_DIVIDER_READ_ONLY) {
-		u32 val;
-
-		val = clk_div_readl(divider) >> divider->shift;
-		val &= clk_div_mask(divider->width);
-
-		return divider_ro_determine_rate(hw, req, divider->table,
-						 divider->width,
-						 divider->flags, val);
-	}
-
-	return divider_determine_rate(hw, req, divider->table, divider->width,
-				      divider->flags);
-}
-
 int divider_get_val(unsigned long rate, unsigned long parent_rate,
 		    const struct clk_div_table *table, u8 width,
 		    unsigned long flags)
@@ -522,7 +501,6 @@ static int clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,
 const struct clk_ops clk_divider_ops = {
 	.recalc_rate = clk_divider_recalc_rate,
 	.round_rate = clk_divider_round_rate,
-	.determine_rate = clk_divider_determine_rate,
 	.set_rate = clk_divider_set_rate,
 };
 EXPORT_SYMBOL_GPL(clk_divider_ops);
@@ -530,7 +508,6 @@ EXPORT_SYMBOL_GPL(clk_divider_ops);
 const struct clk_ops clk_divider_ro_ops = {
 	.recalc_rate = clk_divider_recalc_rate,
 	.round_rate = clk_divider_round_rate,
-	.determine_rate = clk_divider_determine_rate,
 };
 EXPORT_SYMBOL_GPL(clk_divider_ro_ops);
 
-- 
2.49.0


From c75751d622ee7c1f1ae5154b31a3939f93f7b60a Mon Sep 17 00:00:00 2001
From: Urja Rannikko <urjaman@gmail.com>
Date: Mon, 25 Dec 2023 18:06:10 +0200
Subject: [PATCH 15/15] dts: veyron: bluetooth: disable dma on uart0

I just pulled this off the internet ;)
https://codeberg.org/petms/linux-veyron-patches-and-apkbuild
---
 arch/arm/boot/dts/rockchip/rk3288.dtsi | 2 --
 1 file changed, 2 deletions(-)

diff --git a/arch/arm/boot/dts/rockchip/rk3288.dtsi b/arch/arm/boot/dts/rockchip/rk3288.dtsi
index 1cfa4eda5abf..bba671f0de4f 100644
--- a/arch/arm/boot/dts/rockchip/rk3288.dtsi
+++ b/arch/arm/boot/dts/rockchip/rk3288.dtsi
@@ -378,8 +378,6 @@
 		reg-io-width = <4>;
 		clocks = <&cru SCLK_UART0>, <&cru PCLK_UART0>;
 		clock-names = "baudclk", "apb_pclk";
-		dmas = <&dmac_peri 1>, <&dmac_peri 2>;
-		dma-names = "tx", "rx";
 		pinctrl-names = "default";
 		pinctrl-0 = <&uart0_xfer>;
 		status = "disabled";
-- 
2.49.0

